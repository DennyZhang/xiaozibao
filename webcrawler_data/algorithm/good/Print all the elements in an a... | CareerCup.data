id: 8f7793ea9b8d65ff6725f23c60cf83d1

source: http://www.careercup.com/question?id=5118048302268416

summary: 

title: 

status: 

--text follows this line--


  Software Engineer / Developers

s

 Print all the elements in an array that have occurred an odd number of times. I know we can XOR all numbers, but that only solves the problem where there is only one odd number in the array. But I was asked to find all of them. Another method I can think of is to keep one hashset, then walk through the array, if the number is in the map, remove it. If the number is not present, add it. But this requires O(n) space. Is there any way to do this with O(n) time and O(1) space?

-  GZ_Penny  on February 04, 2014 in United States
  Edit  |  Report Duplicate  |  Flag

 Amazon

 Software Engineer / Developer

 Algorithm

  

  

  

  

 Country:  United States

 Interview Type:  In-Person

  Comment hidden because of low score. Click to expand.

 I believe in case when there are several odd numbers you can solve it in two ways:
) The one which you have already mentioned using HashSet-Time O(n), Space O(n)
) Sort the array and then iterate keeping the running counter of the current number. When you reach a new  number check if the counter is odd and print number if it is. Time O(nlogn), Space O(1)

-
 thelineofcode
 on February 04, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

s

 Sorting the original array , distort the original array so it depends on question .

Like to add one more method using modified algo for Binary search tree and keep pointer of count on each node. Print any traversal with node having count odd

Time Complexity : o(nlogn)
space complexity o(n)

best algo will be sorting only o(nlogn) . we can use heap sort or Quick sort. as count sort requires o(n) space.

-
Raj
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

 Only 1 bit is required to store whether the number has occurred odd number of times. So if all the numbers in the list are positive, then we have 1 bit in each array index. When iterating through the array, read the value 'x' after ignore the most significant bit (since it indicates odd or not), index into the array at position 'x' and toggle the most significant bit.
Then go through the array again and if the most significant bit is set, then the corresponding index has occurred odd number of times.

-
Avinash
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

 Another way, without extra memory - sort, and then simply iterate through array. O(n logn)

-
GK
 on February 04, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

 You can use count sort algorithm here.

-
 Ricky
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

 //the solution given works only when the range of numbers in the array is not more than n,i have taken assumption that range is between 0 to n-1. solution is O(n) time and O(1) space.
//  void no_odd_times(int arr[],int n)
{
  //assuming array has no.s between 0 to n-1;
  int max = n;
  int i;
  for(i = 0; i  = n
  if((arr[i]/n) & 1)  //no. of times n is added is odd
  printf(" %d ,count:%d\n",i,arr[i]/n);  //arr[i]/n is the count of i
  }
}

-
Sumit Monga
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

s

 Can you explain me about your algorithm with the following array
{1,3,5,7,1,3,5,7,2,4,5,7}

-
Rajesh M
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

s

 what i have done is since the elements are from 0 to n-1 and so are indexes in the array,so at a particular index i, use the value to modify its actual place by adding maximum value(n) had we have a sorted and distinct array of n elements .mod is taken because the current element might be modified i.e added n one or many times by elements before visited i.e from index 0 to i-1. After doing this ,visit the elements ,if it is

-
Sumit Monga
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

 we can use XOR to partition the array recursively, the base case is all elements in current partition is identical, then, if the size of this partition is odd, print the first elements of the partition.  void print_quick(const vector  &array, int mask, int partition_mask)
{
  if (array.empty()) return;

  int i = 0;
  for (; i  =array.size()) return;

  int first = array[i];
  int r = 0;
  int cnt = 1;
  i++;
  for ( ; i

-
llq
 on February 05, 2014  Edit  |  Flag

  Comment hidden because of low score. Click to expand.

s

 call the function print_quick(array,0,0), means that at first time, the whole array is the partition

-
llq
 on February 05, 2014  Edit  |  Flag

  

  

  

  

 function validate(){return true;}

  Add a Comment
